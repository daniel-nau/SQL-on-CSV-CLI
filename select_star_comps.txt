Average of 250 runs of "SELECT * FROM data/small_tall.csv"

fn select_star(file_path: &str) -> Result<(), Box<dyn Error>> {
    // XXX: V1: 0.0336 seconds
    // let _output = Command::new("cat")
    //     .arg(file_path)
    //     .output()?;

    // Ok(())

    // XXX: V2: 0.0733 seconds
    // // Read the CSV file and get headers
    // let (headers, mut rdr) = csv_reader::read_csv(file_path)?;

    // // Print headers
    // println!("{}", headers.join(","));

    // // Process and print each record
    // for result in rdr.records() {
    //     let record = result?;
    //     println!("{}", record.iter().collect::<Vec<&str>>().join(","));
    // }

    // Ok(())

    // XXX: V3: .0822 seconds
    // // Read the CSV file and get headers
    // let (headers, mut rdr) = csv_reader::read_csv(file_path)?;

    // // Print headers
    // println!("{}", headers.join(","));

    // // Process and print each record
    // let mut record_string = String::new();
    // for result in rdr.records() {
    //     let record = result?;
    //     record_string.clear();
    //     for (i, field) in record.iter().enumerate() {
    //         if i > 0 {
    //             record_string.push(',');
    //         }
    //         record_string.push_str(field);
    //     }
    //     println!("{}", record_string);
    // }

    // Ok(())

    // XXX: V4: .0663 seconds
    // // Read the CSV file and get headers
    // let (headers, mut rdr) = csv_reader::read_csv(file_path)?;

    // // Print headers
    // println!("{}", headers.join(","));

    // // Process and print each record
    // let mut record_string = Vec::new();
    // let stdout = io::stdout();
    // let mut handle = stdout.lock();

    // for result in rdr.records() {
    //     let record = result?;
    //     record_string.clear();
    //     for (i, field) in record.iter().enumerate() {
    //         if i > 0 {
    //             record_string.push(b',');
    //         }
    //         record_string.extend_from_slice(field.as_bytes());
    //     }
    //     record_string.push(b'\n');
    //     handle.write_all(&record_string)?;
    // }

    // Ok(())

    // XXX: V5: .0645 seconds
    // let (headers, mut rdr) = csv_reader::read_csv(file_path)?;

    // // Print headers
    // let stdout = io::stdout();
    // let mut handle = stdout.lock();
    // writeln!(handle, "{}", headers.join(","))?;

    // // Process and print each record
    // let mut record_string = Vec::with_capacity(1024); // Pre-allocate a buffer
    // for result in rdr.records() {
    //     let record = result?;
    //     record_string.clear();
    //     for (i, field) in record.iter().enumerate() {
    //         if i > 0 {
    //             record_string.push(b',');
    //         }
    //         record_string.extend_from_slice(field.as_bytes());
    //     }
    //     record_string.push(b'\n');
    //     handle.write_all(&record_string)?;
    // }

    // Ok(())

    // XXX: V6: .0500 seconds
    // // Read the CSV file and get headers
    // let (headers, mut rdr) = csv_reader::read_csv(file_path)?;

    // // Print headers
    // let stdout = io::stdout();
    // let mut handle = stdout.lock();
    // writeln!(handle, "{}", headers.join(","))?;

    // // Process and print each record
    // let mut record_string = Vec::with_capacity(1024); // Pre-allocate a buffer
    // let mut output_buffer = Vec::with_capacity(8192); // Buffer for batching writes

    // for result in rdr.records() {
    //     let record = result?;
    //     record_string.clear();
    //     for (i, field) in record.iter().enumerate() {
    //         if i > 0 {
    //             record_string.push(b',');
    //         }
    //         record_string.extend_from_slice(field.as_bytes());
    //     }
    //     record_string.push(b'\n');
    //     output_buffer.extend_from_slice(&record_string);

    //     // Flush the buffer if it gets too large
    //     if output_buffer.len() > 8192 {
    //         handle.write_all(&output_buffer)?;
    //         output_buffer.clear();
    //     }
    // }

    // // Write any remaining data in the buffer
    // if !output_buffer.is_empty() {
    //     handle.write_all(&output_buffer)?;
    // }

    // Ok(())

    // XXX V7 0.0052 seconds (6.5x faster than V1)
    // // Open the file and wrap it in a buffered reader
    // let file = File::open(file_path)?;
    // let mut reader = BufReader::with_capacity(65536, file); // Large buffer for reading

    // // Wrap stdout in a buffered writer
    // let stdout = io::stdout();
    // let mut writer = BufWriter::with_capacity(65536, stdout.lock()); // Large buffer for writing

    // // Buffer for chunks of the file
    // let mut buffer = vec![0; 65536];

    // // Read and write chunks
    // loop {
    //     let bytes_read = reader.read(&mut buffer)?;
    //     if bytes_read == 0 {
    //         break; // EOF
    //     }
    //     writer.write_all(&buffer[..bytes_read])?;
    // }

    // writer.flush()?; // Ensure everything is written
    // Ok(())

    // XXX V8 0.0023 seconds (14.6x faster than V1)
    // // Open the file
    // let file = File::open(file_path)?;
        
    // // Memory-map the file
    // let mmap = unsafe { Mmap::map(&file)? };

    // // Write directly to stdout
    // let stdout = io::stdout();
    // let mut handle = stdout.lock();
    // handle.write_all(&mmap)?;
    // handle.flush()?; // Ensure all data is written out

    // Ok(())

    // XXX V9 0.0022 seconds (15.3x faster than V1)
    // Open the file in read-only mode
    let file = File::open(file_path)?;
    
    // Memory-map the file safely by using a helper function
    let mmap = csv_reader::map_file(&file)?;

    // Write the memory-mapped data directly to stdout
    let stdout = io::stdout();
    let mut handle = stdout.lock();
    handle.write_all(&mmap)?;
    handle.flush()?; // Ensure all data is written out

    Ok(())
}